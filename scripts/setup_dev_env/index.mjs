import crypto from 'crypto';
import fs from 'fs';
import path from 'path';

function randomBase64Url(bytes = 48) {
  return crypto.randomBytes(bytes).toString('base64')
    .replace(/=/g, '')
    .replace(/\+/g, '-')
    .replace(/\//g, '_');
}

function signJwtHS256(secret, payload) {
  const header = { alg: 'HS256', typ: 'JWT' };
  const iat = Math.floor(Date.now() / 1000);
  const exp = iat + 60 * 60 * 24 * 365; // 1 year
  const body = { iss: 'supabase', iat, exp, ...payload };
  const b64u = (obj) => Buffer.from(JSON.stringify(obj)).toString('base64')
    .replace(/=/g, '')
    .replace(/\+/g, '-')
    .replace(/\//g, '_');
  const data = `${b64u(header)}.${b64u(body)}`;
  const sig = crypto.createHmac('sha256', secret).update(data).digest('base64')
    .replace(/=/g, '')
    .replace(/\+/g, '-')
    .replace(/\//g, '_');
  return `${data}.${sig}`;
}

function main() {
  const outDir = path.resolve('/workspace/docker/env');
  const outPath = path.join(outDir, 'dev.env.generated');
  const devEnvPath = path.join(outDir, 'dev.env');

  const POSTGRES_PASSWORD = randomBase64Url(24);
  const SUPABASE_JWT_SECRET = randomBase64Url(48);
  const NEXT_PUBLIC_SUPABASE_ANON_KEY = signJwtHS256(SUPABASE_JWT_SECRET, { role: 'anon', aud: 'authenticated' });
  const SUPABASE_SERVICE_ROLE_KEY = signJwtHS256(SUPABASE_JWT_SECRET, { role: 'service_role', aud: 'authenticated' });
  const NEXT_PUBLIC_SUPABASE_URL = 'http://localhost:54321';
  const REALTIME_SECRET_KEY_BASE = randomBase64Url(48);

  const generated = [
    `# Generated by scripts/setup_dev_env on ${new Date().toISOString()}`,
    `POSTGRES_PASSWORD=${POSTGRES_PASSWORD}`,
    `SUPABASE_JWT_SECRET=${SUPABASE_JWT_SECRET}`,
    `NEXT_PUBLIC_SUPABASE_ANON_KEY=${NEXT_PUBLIC_SUPABASE_ANON_KEY}`,
    `SUPABASE_SERVICE_ROLE_KEY=${SUPABASE_SERVICE_ROLE_KEY}`,
    `NEXT_PUBLIC_SUPABASE_URL=${NEXT_PUBLIC_SUPABASE_URL}`,
    `REALTIME_SECRET_KEY_BASE=${REALTIME_SECRET_KEY_BASE}`,
    '',
  ].join('\n');

  fs.mkdirSync(outDir, { recursive: true });
  fs.writeFileSync(outPath, generated, { encoding: 'utf8' });

  const shouldWrite = process.argv.includes('--write') || process.argv.includes('-w');
  if (shouldWrite) {
    const kv = {
      POSTGRES_PASSWORD,
      SUPABASE_JWT_SECRET,
      NEXT_PUBLIC_SUPABASE_ANON_KEY,
      SUPABASE_SERVICE_ROLE_KEY,
      NEXT_PUBLIC_SUPABASE_URL,
      REALTIME_SECRET_KEY_BASE,
    };
    let existing = '';
    if (fs.existsSync(devEnvPath)) existing = fs.readFileSync(devEnvPath, 'utf8');
    const linesIn = existing.split(/\r?\n/);
    const outLines = [];
    const seen = new Set();
    for (const line of linesIn) {
      const m = line.match(/^([A-Z0-9_]+)=(.*)$/);
      if (m && Object.prototype.hasOwnProperty.call(kv, m[1])) {
        outLines.push(`${m[1]}=${kv[m[1]]}`);
        seen.add(m[1]);
      } else {
        outLines.push(line);
      }
    }
    for (const key of Object.keys(kv)) {
      if (!seen.has(key)) outLines.push(`${key}=${kv[key]}`);
    }
    fs.writeFileSync(devEnvPath, outLines.join('\n'), 'utf8');
    console.log('Updated', devEnvPath, 'with generated keys.');

    // Also write docker/.env for Compose variable substitution (so you can omit --env-file)
    // This file is ignored by git; see .gitignore.
    const composeEnvPath = path.join(outDir, '.env');
    const composeLines = Object.entries(kv)
      .map(([k, v]) => `${k}=${v}`)
      .join('\n') + '\n';
    fs.writeFileSync(composeEnvPath, composeLines, 'utf8');
    console.log('Wrote Compose env to', composeEnvPath, '(used for ${VAR} substitution)');
  } else {
    console.log('Wrote generated env to:', outPath);
    console.log('\nPreview (copy desired lines into docker/env/dev.env):\n');
    console.log(generated);
    console.log('\nTip: run with --write to update docker/env/dev.env directly');
  }
}

main();
